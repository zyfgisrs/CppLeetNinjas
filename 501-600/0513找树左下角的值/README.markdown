# leetcode513 找树左下角的值

## 迭代法
1. **此解决方案的实现原理是什么**：
   - 此方案采用宽度优先搜索(BFS)策略，通过一个队列`nodeQueue`按层级遍历二叉树。
   - 对于每一层，我们只记录这层的第一个节点的值，这是因为我们只需要找到最后一层的最左侧节点的值。
   - 按层次遍历，确保了最后在队列中的一层是最底层，因此返回该层的第一个节点的值就是答案。

2. **代码实现的难点是什么**：
   - 主要是队列的使用以及如何区分每一层的节点，这里使用了一个计数器`count`来记录每层的节点数。

3. **如何处理边界问题**：
   - 对于空节点，代码中已经进行了检查：如果一个节点的左子节点或右子节点存在，则将其加入队列。
   - 对于树只有一个节点的情况，由于在开始时已将根节点加入队列，因此不需要特殊处理。

4. **如何想到这样的代码方案，思路有什么上启发**：
   - 当考虑如何找到最后一层的最左侧节点时，可以联想到层次遍历，因为层次遍历可以确保从上到下、从左到右地访问每一个节点。
   - 由于我们只关心每层的最左侧节点，所以只需要在开始处理新的一层时记录其第一个节点的值即可。

5. **时间复杂度和空间复杂度**：
   - **时间复杂度**：O(N)，其中 N 是二叉树的节点数。这是因为我们需要遍历每个节点。
   - **空间复杂度**：O(W)，其中 W 是二叉树的最大宽度。这是因为最坏的情况下，队列中可能需要存储整个层级的所有节点。

## 递归法

1. **此解决方案的实现原理是什么**：
   - 这个方案使用深度优先搜索(DFS)来遍历整棵树。在遍历的过程中，我们会记录当前节点的深度。
   - 对于每一个节点，我们比较它的深度是否超过当前记录的最大深度。如果超过，我们就更新最大深度并保存这个节点的值作为结果。
   - 为了确保找到最左边的节点，我们先遍历左子树，然后遍历右子树。

2. **代码实现的难点是什么**：
   - 主要是如何正确地传递和更新最大深度和最左下角的值。在这里，我们使用引用`&`来确保在递归过程中可以更新这两个值。
   - 递归的终止条件和深度的传递也是需要注意的地方。

3. **如何处理边界问题**：
   - 当节点为`nullptr`时，函数直接返回，这处理了空节点的情况。
   - 在遍历过程中，深度始终与真实深度保持一致，无需进行额外处理。

4. **如何想到这样的代码方案，思路有什么上启发**：
   - 根据题目要求，我们需要找到最深和最左的节点。很自然地，我们会想到使用某种树的遍历方法。
   - DFS提供了一种简单的方法来记录当前深度，并允许我们首先访问左子树，确保我们找到最左边的节点。
   - 同时，我们注意到要找的节点必然是某一层的第一个节点，因此在每层我们只需记录第一个遍历到的节点。

5. **时间复杂度和空间复杂度**：
   - **时间复杂度**：O(N)，其中 N 是二叉树的节点数。因为每个节点都只被遍历一次。
   - **空间复杂度**：O(H)，其中 H 是二叉树的高度。这是由于递归的调用堆栈。在最坏的情况下，当树完全不平衡时，其复杂度为 O(N)；在最好的情况下，当树完全平衡时，其复杂度为 O(logN)。

