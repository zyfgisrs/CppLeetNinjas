这道题目是检查一颗二叉树是否是对称的。即树的左半部分是否是右半部分的镜像。

## 递归法
首先，解决这道题目的关键思想是：如果一颗二叉树是对称的，那么它的左子树和右子树也应该是对称的。我们可以通过递归来解决这个问题。

以下是该递归解法的详细解释：

### Base Cases:
如果根结点为空，那么树是对称的。
如果一个节点的左孩子为空且右孩子不为空，或左孩子不为空且右孩子为空，则返回false，因为这意味着树不是完全对称的。
如果两个节点都为空，则返回true。
如果两个节点的值不相等，则返回false。

### Recursive Calls:
为了判断左子树和右子树是否对称，我们需要比较左子树的左孩子和右子树的右孩子，同时也需要比较左子树的右孩子和右子树的左孩子。
因此，我们进行了两次递归调用：compare(left->left, right->right) 和 compare(left->right, right->left)。这两次调用分别检查了"外侧"和"内侧"的对称性。
如果上述两次递归调用都返回true，则当前的左子树和右子树是对称的。

### Putting it all together:
调用isSymmetric函数时，首先检查根节点。如果根节点为空，直接返回true。
否则，调用compare函数开始递归地检查左子树和右子树是否对称。
这个递归解法的精髓是使用两个节点（在这里是left和right）来表示当前正在比较的两个对称位置，并使用递归来检查它们的孩子节点是否对称。这种方法允许我们在整个二叉树上以镜像的方式同步地移动两个节点，从而递归地检查整个树的对称性。

## 迭代法
为了使用迭代法解决这个问题，我们可以使用队列。思想是同步地检查两个节点的值是否相等，并将这两个节点的孩子按照镜像的顺序入队。迭代法的核心是确保每次从队列中取出的两个节点都是对称的。
解释：
1. 如果根为空，直接返回 `true`。
2. 初始化一个队列，并将根的左、右子节点入队。
3. 进入循环，每次从队列中取出两个节点，并进行比较：
    - 如果两个节点都为 `nullptr`，则它们是对称的，继续下一轮迭代。
    - 如果其中一个节点为 `nullptr`，则它们不对称，返回 `false`。
    - 如果两个节点的值不等，返回 `false`。
4. 如果当前两个节点对称，那么将这两个节点的孩子按照镜像的顺序入队：先是第一个节点的左孩子和第二个节点的右孩子，然后是第一个节点的右孩子和第二个节点的左孩子。
5. 循环继续直到队列为空。
6. 如果能完成整个循环而没有返回 `false`，那么整个树是对称的，所以返回 `true`。

队列确保了我们同步地检查两个对称位置的节点，并在整个二叉树上以镜像的方式进行。