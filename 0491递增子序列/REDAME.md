## leetcode491-递增子序列

1. **解决方案的基本原理**

这个问题的解决方案依赖于深度优先搜索(DFS)的方法，我们试图找到数组`nums`中所有的递增子序列。我们通过递归探索可能的路径，构建子序列。为了避免重复和确保递增，我们使用一个集合`set`来记录在当前递归层次在同一位置考虑过的元素，并且在递归调用中保证只向子序列中添加不小于当前子序列最后一个元素的数。

2. **实现中可能的挑战**

- 处理重复元素：数组中可能存在重复元素，要确保生成的子序列是唯一的。
- 保证递增顺序：在构建子序列时，要确保新加入的元素不小于子序列中的最后一个元素。
- 递归的终止条件和边界处理：要正确处理递归的终止条件，并在实现中正确处理数组边界。

3. **边界情况的处理**

在此代码中，边界情况主要体现在以下几点：
- 如果`current`的大小至少为2，就将其添加到结果集`combinations`中，确保所有返回的子序列至少有两个元素。
- 递归的终止条件：如果`i`等于`nums.size()`，递归调用将终止。
- 当`current.back() > nums[i]`时，不继续递归，确保添加到子序列中的元素始终是递增的。

4. **深入见解或启示**

使用DFS在这种问题上的主要启示来自于其问题的递归结构：我们可以构建一个子序列，然后在这个基础上继续构建更长的子序列。这自然引导我们思考使用递归方法（尤其是DFS）来解决问题。此外，由于要求返回的子序列是唯一的，我们使用一个集合来跟踪和消除重复项，这是处理此类问题中重复元素的一种常见策略。

5. **时间和空间复杂度**

- 时间复杂度：由于我们要遍历数组中的每一个元素，并在每一步进行递归调用，所以时间复杂度是O(2^N)，其中N是`nums`的长度。每一步我们都可以选择添加或不添加当前元素到当前子序列中，因此存在2^N种可能的组合。
- 空间复杂度：递归的调用栈深度最大为N，所以空间复杂度是O(N)。如果考虑输出的空间，由于可能的子序列数量最多为2^N，所以最坏情况下的空间复杂度是O(2^N)。


6. **消除重复项思路**

在这个问题中，对于每个`for`循环中的每个元素，我们通过深度优先搜索（DFS）递归地尝试构建所有可能的递增子序列。由于我们想要找到的是所有**不同**的递增子序列，如果在`nums`中存在重复元素，而且我们不在每次`for`循环中消除重复项的话，我们就会得到重复的子序列。

为了理解为什么`for`循环中需要消除重复项，考虑下面这个简单的例子：假设`nums` = `[4, 4, 3, 7]`，并且我们当前正在考虑第一个元素（`4`）。

- 首先，我们把第一个`4`添加到`current`中，并递归地在剩下的元素中寻找递增子序列。
- 接下来，在递归返回后，我们从`current`中移除第一个`4`，并在下次迭代中考虑第二个`4`。

如果我们不消除重复项，第二个`4`将会再次被添加到`current`中，并且我们将再次递归地在剩下的元素中寻找递增子序列。由于剩下的元素和第一次递归时的情况完全相同，我们将会得到完全一样的子序列，从而导致重复。

因此，为了确保我们不会得到重复的子序列，我们在每个`for`循环中使用一个集合`set`来消除重复项。具体来说，在处理`nums[i]`之前，我们首先检查`nums[i]`是否已经在`set`中。如果`nums[i]`不在`set`中，我们把它添加到`set`和`current`中，并继续递归。如果`nums[i]`已经在`set`中，我们就跳过当前的迭代，以避免重复。

这种方法确保了每个递增子序列只会被找到一次，即使`nums`中存在重复元素。在具体实现中，由于我们使用`unordered_set`来消除重复项，我们还能确保每次检查一个元素是否在集合中的操作时间复杂度为O(1)，从而保持了算法整体的效率。


