# leetcode-235-二叉树的最近公共祖先

### 递归法

**1. 解决方案的基本原理：**
这个解决方案是基于递归的，我们从根节点开始检查，如果两个目标节点分别位于当前节点的左右侧，那么当前节点就是它们的最近公共祖先。如果它们都在左侧或都在右侧，则递归检查相应的子树。

**2. 在代码实现过程中可能遇到的挑战：**
递归需要正确的退出条件。这里的退出条件是：如果当前节点为空，或者与目标节点之一相等，则直接返回当前节点。

**3. 边界情况是如何处理的：**
- 如果 `p` 和 `q` 都在左子树，那么返回的是左子树的结果。
- 如果 `p` 和 `q` 都在右子树，那么返回的是右子树的结果。
- 如果一个在左子树，另一个在右子树，那么返回根节点。

**4. 怎样想到这种编码方法，以及导致这种方法的见解是什么：**
在普通的二叉树中，我们无法像在二叉搜索树中那样利用节点值的性质。因此，我们需要递归地检查每个节点的左右子树。这种方法的核心思想是逐步缩小目标节点的搜索范围。

**5. 评估其时间和空间复杂度：**
- 时间复杂度：最坏情况下，需要遍历所有节点，所以是 O(n)，其中 n 是二叉树的节点数。
- 空间复杂度：考虑到递归的函数调用，最坏情况下，调用栈的深度是 n，所以是 O(n)。


### 哈希表法
对于您提供的这个解决方案，以下是相关的总结和组织：

**1. 解决方案的基本原理：**
该解决方案首先使用深度优先搜索（DFS）遍历整棵树，同时利用一个哈希表 `node_to_parent_map` 来记录每个节点的父节点。之后，从节点 `p` 开始，沿着其父节点路径，直到根节点，并将这些节点存储在 `ancestors` 集合中。接着，再从节点 `q` 开始，沿着其父节点路径，查找第一个在 `ancestors` 集合中出现的节点，该节点即为 `p` 和 `q` 的最近公共祖先。

**2. 在代码实现过程中可能遇到的挑战：**
- 确保在 DFS 遍历过程中正确地记录每个节点的父节点。
- 确保在查找 `p` 和 `q` 的公共祖先时，哈希表和集合的操作是正确的。

**3. 边界情况是如何处理的：**
- 如果 `p` 和 `q` 没有公共祖先，函数会返回 `nullptr`。

**4. 怎样想到这种编码方法，以及导致这种方法的见解是什么：**
考虑到二叉树中节点没有指向父节点的指针，但为了找到最近公共祖先，我们需要知道每个节点的父节点是谁。因此，可以首先遍历整棵树，记录每个节点的父节点。这种方法的核心思想是，通过父节点路径，我们可以从任何节点开始，一直回溯到根节点。

**5. 评估其时间和空间复杂度：**
- 时间复杂度：`O(n)`，其中 `n` 是二叉树的节点数。我们需要遍历所有节点来构建 `node_to_parent_map`，然后最多遍历两次所有节点来查找 `p` 和 `q` 的最近公共祖先。
- 空间复杂度：`O(n)`，因为我们存储了每个节点的父节点。

