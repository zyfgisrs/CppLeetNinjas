## leetcode669 修剪二叉搜索树
1. **基本原理**:
   这个解决方案基于递归的方法来修剪二叉搜索树（BST）。根据BST的性质，我们可以通过比较节点值和给定的边界来决定如何修剪。具体来说：
   - 如果节点值小于`low`边界，那么这个节点及其左子树都应该被修剪，我们只需要在右子树上继续递归。
   - 如果节点值大于`high`边界，那么这个节点及其右子树都应该被修剪，我们只需要在左子树上继续递归。
   - 如果节点值在`low`和`high`之间，我们需要保留这个节点，但是要在它的左子树和右子树上继续递归修剪。

2. **具体的挑战**:
   - 确保递归的终止条件正确，以避免无限递归。
   - 理解和保持二叉搜索树的性质，确保修剪后的树仍然是有效的BST。
   - 正确处理边界情况，例如空树、单节点树或所有节点都需要被修剪的情况。

3. **边界情况处理**:
   - 空树: 如果`root`是`nullptr`，函数直接返回`nullptr`。
   - 单节点树: 由于是递归实现，单节点树和普通树将以相同的方式处理。
   - 无需修剪的情况和全部需要修剪的情况都可以通过递归逻辑正确处理。

4. **深入见解/启示**:
   - 利用BST的性质和递归是解决此问题的关键。通过比较节点值和给定边界，我们可以确定应该在左子树、右子树或两者上继续递归。
   - 递归方法允许我们以简洁和直观的方式表达解决方案，而不需要复杂的循环或额外的数据结构。

5. **时间和空间复杂度**:
   - **时间复杂度**: 该解决方案的时间复杂度为O(N)，其中N是树中节点的数量。在最坏的情况下，我们需要访问树中的每个节点一次。
   - **空间复杂度**: 递归方法的空间复杂度为O(H)，其中H是树的高度，对应于递归栈的最大深度。在最坏的情况下，当树成为链表时，空间复杂度为O(N)。